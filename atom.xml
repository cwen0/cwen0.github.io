<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>cwen&#39;s blog</title>
  <id>http://www.cwen.pw</id>
  <updated>2016-11-06T13:45:14+08:00</updated>
  <subtitle>沉稳，不乏可爱</subtitle>
  <link href="http://www.cwen.pw"></link>
  <entry>
    <title>ljgo - 静态博客引擎(0.1.0-beta版)</title>
    <updated>2016-09-08T00:00:00Z</updated>
    <id>tag:www.cwen.pw,2016-09-08:/2016/ljgo - 静态博客引擎(0.1.0-beta版).html</id>
    <content type="html">&lt;p&gt;ljgo 是使用GO 语言实现的简单静态博客引擎, 编译速度快、安装简单。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;目前版本 0.1.0-beta&lt;/h4&gt;&#xA;&#xA;&lt;h2&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;源码安装&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;go运行环境安装请自行google&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go get -u github.com/cwen-coder/ljgo&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;直接下载编译好的可执行文件&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;下载地址 ： &lt;a href=&#34;https://github.com/cwen-coder/ljgo/releases&#34;&gt;ljgo&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;快速入门&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;新建站点&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ljgo new example.com&#xA;#执行完毕后，会在生成example.com文件夹&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;example.com&lt;/code&gt; 文件夹目录结构&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;- config.yml    // 站点配置文件&#xA;- source // 保存文章目录&#xA;- - | - - about.md // 关于页面内容&#xA;- - | - - article.md // 演示文章内容&#xA;- themes  // 保存所有主题&#xA;- - | - - default // 站点默认主题&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;config.yml&lt;/code&gt; 配置格式&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;site:&#xA;    title: 网站标题&#xA;    introduce: 网站描述&#xA;    limit: 每页可显示的文章数目&#xA;    theme: 网站主题目录   ＃eg: themes/default&#xA;    url: 站点域名&#xA;    comment: 评论插件变量(默认为Disqus账户名)&#xA;    github: github.com 地址 # 可选&#xA;    facebook: facebook 地址  # 可选&#xA;    twitter: twitter 地址  # 可选&#xA;serve:&#xA;    addr: ljgo serve 监听地址 # eg: &amp;quot;localhost:3000&amp;quot;&#xA;&#xA;publish:&#xA;    cmd: |&#xA;        ljgo publish 命令将会执行的脚本&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;创建文章&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在source目录中建立任意.md文件（可置于子文件夹），使用如下格式：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;title: 文章标题&#xA;author: 文章作者&#xA;date: 2016-08-02&#xA;update: 2016-08-02&#xA;tags:&#xA;    - 设计&#xA;    - 写作&#xA;&#xA;---&#xA;&#xA;文章预览内容&#xA;    &amp;lt;!--more--&amp;gt;&#xA;文章其它内容&#xA;(文章的全部内容＝预览＋其他)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;生成静态页面&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ljgo build&#xA;# 执行完毕在站点文件下生成public文件夹，包含所有静态文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;dl&gt;&#xA;&lt;dt&gt;在站点文件夹中直接执行 &lt;code&gt;ljgo build&lt;/code&gt; ， 或是在站点文件夹外执行但是得指定站点路径 eg&lt;/dt&gt;&#xA;&lt;dd&gt;&lt;code&gt;ljgo build example.com&lt;/code&gt;&#xA;&lt;code&gt;ljgo serve&lt;/code&gt; &lt;code&gt;ljgo publis&lt;/code&gt; 都是同样的使用姿势&lt;/dd&gt;&#xA;&lt;/dl&gt;&#xA;&#xA;&lt;h4&gt;本地预览&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ligo serve&#xA;# 打来浏览器, 访问你在站点配置中填入的端口地址&#xA;# 默认是 http://localhost:3000&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当然你也可以直接将 &lt;code&gt;ljgo serve&lt;/code&gt; 运行在 &lt;code&gt;vps&lt;/code&gt; 上&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;部署&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;你可以使用 &lt;a href=&#34;https://pages.github.com/&#34;&gt;github pages&lt;/a&gt; 等服务，或者放到你的自己的vps下，因为是纯静态文件,不需要php/mysql/java等环境的支持&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ljgo publish&#xA;# 执行站点配置中填写的发布脚本&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;eg : 使用 &lt;code&gt;github&lt;/code&gt;服务， 初始化好 &lt;code&gt;public&lt;/code&gt;  文件夹后，我们只需要在 &lt;code&gt;config.yml&lt;/code&gt; 文件中的填写如下内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;publish:&#xA;    cmd: |&#xA;        git add -A&#xA;        git commit -m &amp;quot;update&amp;quot;&#xA;        git push origin&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样我们在每次编辑完博客后直接运行 &lt;code&gt;ljgo publish&lt;/code&gt; 就一切ok&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;关于主题&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;由于自己比较懒，目前的默认主题是从 &lt;a href=&#34;https://startbootstrap.com&#34;&gt;start bootstrapt&lt;/a&gt; 中的 &lt;a href=&#34;https://startbootstrap.com/template-overviews/clean-blog/&#34;&gt;clean-blog&lt;/a&gt; 修改而来&#xA;当导入其他主题，需要把主题文件夹复制到 &lt;code&gt;example.com/themes/&lt;/code&gt; 文件夹下，并修改站点配置 &lt;code&gt;config.yml&lt;/code&gt; 中主题路径&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;十分欢迎大家贡献第三方主题 👏&lt;/h4&gt;&#xA;&#xA;&lt;h2&gt;正在使用&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cwen.pw&#34;&gt;cwen&amp;rsquo;s blog&lt;/a&gt;           - me&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;期待更多的用户&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;反馈贡献&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;非常欢迎任何人的任何贡献。如有问题可报告至 &lt;a href=&#34;https://github.com/cwen-coder/ljgo/issues&#34;&gt;https://github.com/cwen-coder/ljgo/issues&lt;/a&gt;。&#xA;或是直接发邮件To me &lt;a href=&#34;mailto:yincwengo@gmail.com&#34;&gt;yincwengo@gmail.com&lt;/a&gt;&lt;/p&gt;&#xA;</content>
    <link href="http://www.cwen.pw/2016/ljgo - 静态博客引擎(0.1.0-beta版).html"></link>
    <author>
      <name>cwen</name>
    </author>
  </entry>
  <entry>
    <title>go笔记-关于GC</title>
    <updated>2016-08-20T00:00:00Z</updated>
    <id>tag:www.cwen.pw,2016-08-20:/2016/go笔记-关于GC.html</id>
    <content type="html">&lt;p&gt;GO “非分代的、非紧缩、写屏障、并发标记清理”&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;并发清理： 垃圾回收(清理过程)与用户逻辑并发执行&#xA;  三色并发标记 :  标记与用户逻辑并发执行&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;一般常用垃圾回收方法&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引用计数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个 引用计数 ，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。&#xA;  #### 优点&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;是实现简单，并且内存的回收很及时。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;#### 缺点&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;频繁更新引用计数降低了性能&#xA;循环引用问题&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记-清除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;该方法分为两步， 标记 从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行 清除 操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！当然后续也出现了很多mark&amp;amp;sweep算法的变种（如 三色标记法 ）优化了这个问题。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分代收集&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;经过大量实际观察得知，在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为 代（generation） 的空间。新创建的对象存放在称为 新生代（young generation） 中（一般来说，新生代的大小会比 老年代 小很多），随着垃圾回收的重复执行，生命周期较长的对象会被 提升（promotion） 到老年代中。因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;三色并发标记 (1.5之后使用GC方法)&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;In a tri-color collector, every object is either white, grey, or black and we view the heap as a graph of connected objects. At the start of a GC cycle all objects are white. The GC visits all roots, which are objects directly accessible by the application such as globals and things on the stack, and colors these grey. The GC then chooses a grey object, blackens it, and then scans it for pointers to other objects. When this scan finds a pointer to a white object, it turns that object grey. This process repeats until there are no more grey objects. At this point, white objects are known to be unreachable and can be reused.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这是让标记与用户代码并发的基本保障， 基本原理：&#xA;* 起初所有对象都是白色&#xA;* 扫描所有可达对象，标记为灰色，放入待处理队列&#xA;* 从队列提取灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色&#xA;* 写屏障监控对象内存修改，从新标色或是放入队列&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当完成所有的扫描和标记的工作后，剩余不是白色就是黑色，分别代表要回收和活跃对象，清理操作只需要把白色对象回收内存回收就好&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xnp02.com1.z0.glb.clouddn.com/Animation_of_tri-color_garbage_collection.gif&#34; alt=&#34;三色并发标记&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;增量&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;三色标记的目的，主要是用于做增量的垃圾回收。注意到，如果只有黑色和白色两种颜色，那么回收过程将不能中断，必须一次性完成，期间用户程序是不能运行的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而使用三色标记，即使在标记过程中对象的引用关系发生了改变，例如分配内存并修改对象属性域的值，只要满足黑色对象不引用白色对象的约束条件，垃圾回收器就可以继续正常工作。于是每次并不需要将回收过程全部执行完，只是处理一部分后停下来，后续会慢慢再次触发的回收过程，实现增量回收。相当于是把垃圾回收过程打散，减少停顿时间。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;写屏障 (write barrier)&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;如果是STW的，三色标记没有什么问题。但是如果允许用户代码跟垃圾回收同时运行，需要维护一条约束条件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;黑色对象绝对不能引用白色对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;为什么不能让黑色引用白色？因为黑色对象是活跃对象，它引用的对象是也应该属于活跃的，不应该被清理。但是，由于在三色标记算法中，黑色对象已经处理完毕，它不会被重复扫描。那么，这个对象引用的白色对象将没有机会被着色，最终会被误当作垃圾清理。&#xA;STW中，一个对象，只有它引用的对象全标记后才会标记为黑色。所以黑色对象要么引用的黑色对象，要么引用的灰色对象。不会出现黑色引用白色对象。&#xA;对于垃圾回收和用户代码并行的场景，用户代码可能会修改已经标记为黑色的对象，让它引用白色对象。看一个例子来说明这个问题：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;stack -&amp;gt; A.ref -&amp;gt; B&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;A是从栈对象直接可达，将它标记为灰色。此时B是白色对象。假设这个时候用户代码执行：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;localRef = A.ref&#xA;A.ref = NULL&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;localRef是栈上面的一个黑色对象，前一行赋值语句使得它引用到B对象。后一行A.ref被置为空之后，A将不再引用到B。A是灰色但是不再引用到B了，B不会着色。localRef是黑色，处理完毕的对象，引用了B但是不会被再次处理。于是B将永远不再有机会被标记，它会被误当作垃圾清理掉！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果实现满足这种约束条件呢？write barrier!&#xA;来自wiki的对这个术语的解释：&amp;rdquo;A write barrier in a garbage collector is a fragment of code emitted by the compiler immediately before every store operation to ensure that (e.g.) generational invariants are maintained.&amp;rdquo; 即是说，在每一处内存写操作的前面，编译器会生成的一小段代码段，来确保不要打破一些约束条件。&#xA;增量和分代，都需要维护一个write barrier。&#xA;先看分代的垃圾回收，跨越不同分代之间的引用，需要特别注意。通常情况下，大多数的交叉引用应该是由新生代对象引用老生代对象。当我们回收新生代的时候，这没有什么问题。但是当我们回收老生代的时候，如果只扫描老生代不扫描新生代，则老生代中的一些对象可能被误当作不可达对象回收掉！为了处理这种情况，可以做一个约定&amp;ndash;如果回收老生代，那么比它年轻的新生代都要一起回收一遍。另外一种交叉引用是老生代对象引用到新生代对象，这时就需要write barrier了，所有的这种类型引用都应该记录下来，放到一个集合中，标记的时候要处理这个集合。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;再看三色标记中，黑色对象不能引用白色对象。这就是一个约束条件，write barrier就是要维护这条约束。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;go1.5  GC 实现过程&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xnp02.com1.z0.glb.clouddn.com/gc.png&#34; alt=&#34;gc 过程&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;Go1.5垃圾回收的实现被划分为五个阶段：&lt;/h4&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GCoff 垃圾回收关闭状态&lt;/li&gt;&#xA;&lt;li&gt;GCscan 扫描阶段&lt;/li&gt;&#xA;&lt;li&gt;GCmark 标记阶段，write barrier生效&lt;/li&gt;&#xA;&lt;li&gt;GCmarktermination 标记结束阶段，STW，分配黑色对象&lt;/li&gt;&#xA;&lt;li&gt;GCsweep 清扫阶段&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xnp02.com1.z0.glb.clouddn.com/gogc.png&#34; alt=&#34;gc  过程&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;控制器&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;全程参与并发回收任务， 记录相关状态数据， 动态调整运行策略，影响并发标记工作单元的工作模式和数量， 平衡CPU资源占用。当回收结束时，参与next_gc 回收阀值设置，调整垃圾回收触发频率&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;过程&lt;/h4&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;设置 &lt;code&gt;gcprecent(GOGC)&lt;/code&gt; 和 &lt;code&gt;next_gc&lt;/code&gt; 阀值&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;启动&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;在为对象分配堆内存后，&lt;code&gt;mallocgo&lt;/code&gt; 函数会检查垃圾回收触发条件，并依照相关状态启动或参与辅助回收&#xA;垃圾回收默认以全并发，但可用环境变量或事参数禁用并发标记和并发清理，gc goroutine 一直循环，直到符合触发条件时被唤醒&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;分俩步骤&#xA;&amp;gt; 扫描 ：遍历相关内存区域，依照指针标记找出灰色可达对象，加入队列 。扫描函数 (gcscan_m) 启动时，用户代码和标记函数 (MarkWorker) 都在运行&#xA;&amp;gt; 标记 ： 将灰色对象从队列中取出，将其应用对象标记为灰色，自身标记为黑色。 并发标记由多个MarkWorker goroutine 共同完成，它们在回收任务完成前绑定到 P ， 然后进入休眠状态，知道被调度器唤醒&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;清理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;清理未被标记的白色对象 ，将其内存回收&lt;/p&gt;&#xA;&#xA;&lt;p&gt;并发清理本质上是一个死循环，被唤醒后开始执行清理任务。 通过遍历所有span 对象，触发内存回收器的回收操作。任务完成后，再次休眠，等待下次任务&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;监控&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;模拟情景：服务重启，海量服务重新接入，瞬间分配大量对象，将垃圾回收触发阀值next_gc推到一个很大的值。而当服务正常后，因活跃对象远小于该阀值，造成垃圾回收迟迟无法触发，大量白色对象无法回收，造成隐形内存泄漏。同样情景也有可能由于某个算法在短期内大量使用临时变量造成 。&#xA;这个时候只有forcegc介入，才能将next_gc恢复正常， 监控服务sysmon每隔两分钟检查一次垃圾回收状态，如果超过两分钟未曾触发，就会强制执行gc&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gc 过程中几种辅助结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;parfor 并行任务框架 ： 关注的是任务的分配和调度，自身不具备执行能力。它将多个任务分组交给多个执行线程。然后在执行过程中重新平衡线程的任务分配，确保整个任务在最短的时间内完成&#xA;缓存队列： workbuf 无锁栈节点，本身是一个缓存容器&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;问题&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;go程序内存占用大的问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;我们模拟大量的用户请求访问后台服务，这时各服务模块能观察到明显的内存占用上升。但是当停止压测时，内存占用并未发生明显的下降。花了很长时间定位问题，使用gprof等各种方法，依然没有发现原因。最后发现原来这时正常的…主要的原因有两个，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一是go的垃圾回收有个触发阈值，这个阈值会随着每次内存使用变大而逐渐增大（如初始阈值是10MB则下一次就是20MB，再下一次就成为了40MB…），如果长时间没有触发gc go会主动触发一次（2min）。高峰时内存使用量上去后，除非持续申请内存，靠阈值触发gc已经基本不可能，而是要等最多2min主动gc开始才能触发gc。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;第二个原因是go语言在向系统交还内存时只是告诉系统这些内存不需要使用了，可以回收；同时操作系统会采取“拖延症”策略，并不是立即回收，而是等到系统内存紧张时才会开始回收这样该程序又重新申请内存时就可以获得极快的分配速度。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gc时间长的问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;对于对用户响应事件有要求的后端程序，golang gc时的stop the world兼职是噩梦。根据上文的介绍，1.5版本的go再完成上述改进后应该gc性能会提升不少，但是所有的垃圾回收型语言都难免在gc时面临性能下降，对此我们对于应该尽量避免频繁创建临时堆对象（如&amp;amp;abc{}, new, make等）以减少垃圾收集时的扫描时间，对于需要频繁使用的临时对象考虑直接通过数组缓存进行重用；很多人采用cgo的方法自己管理内存而绕开垃圾收集，这种方法除非迫不得已个人是不推荐的（容易造成不可预知的问题），当然迫不得已的情况下还是可以考虑的，这招带来的效果还是很明显的~&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;goroutine泄露的问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;我们的一个服务需要处理很多长连接请求，实现时，对于每个长连接请求各开了一个读取和写入协程，全部采用endless for loop不停地处理收发数据。当连接被远端关闭后，如果不对这两个协程做处理，他们依然会一直运行，并且占用的channel也不会被释放…这里就必须十分注意，在不使用协程后一定要把他依赖的channel close并通过再协程中判断channel是否关闭以保证其退出。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如何测量GC&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ go build -gcflags &amp;quot;-l&amp;quot; -o test test.go&#xA;$ GODEBUG=&amp;quot;gctrace=1&amp;quot; ./test&#xA;&#xA;gctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard&#xA;error at each collection, summarizing the amount of memory collected and the&#xA;length of the pause. Setting gctrace=2 emits the same summary but also&#xA;repeats each collection.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;之前说了那么多，那如何测量gc的之星效率，判断它到底是否对程序的运行造成了影响呢？ 第一种方式是设置godebug的环境变量，比如运行GODEBUG=gctrace=1 ./myserver，如果要想对于输出结果了解，还需要对于gc的原理进行更进一步的深入分析，这篇文章的好处在于，清晰的之处了golang的gc时间是由哪些因素决定的，因此也可以针对性的采取不同的方式提升gc的时间：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据之前的分析也可以知道，golang中的gc是使用标记清楚法，所以gc的总时间为：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Tgc = Tseq + Tmark + Tsweep(T表示time)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Tseq表示是停止用户的 goroutine 和做一些准备活动（通常很小）需要的时间&#xA;Tmark 是堆标记时间，标记发生在所有用户 goroutine 停止时，因此可以显著地影响处理的延迟&#xA;Tsweep 是堆清除时间，清除通常与正常的程序运行同时发生，所以对延迟来说是不太关键的&#xA;之后粒度进一步细分，具体的概念还是有些不太懂：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;与Tmark相关的：1 垃圾回收过程中，堆中活动对象的数量，2 带有指针的活动对象占据的内存总量 3 活动对象中的指针数量。&#xA;与Tsweep相关的：1 堆内存的总量 2 堆中的垃圾总量&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如何进行gc调优（gopher大会 Danny）&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;硬性参数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;涉及算法的问题，总是会有些参数。GOGC参数主要控制的是下一次gc开始的时候的内存使用量。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如当前的程序使用了4M的对内存（这里说的是堆内存），即是说程序当前reachable的内存为4m，当程序占用的内存达到reachable*(1+GOGC/100)=8M的时候，gc就会被触发，开始进行相关的gc操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如何对GOGC的参数进行设置，要根据生产情况中的实际场景来定，比如GOGC参数提升，来减少GC的频率。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;参考&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go15gc&#34;&gt;go15gc&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://talks.golang.org/2015/go-gc.pdf&#34;&gt;https://talks.golang.org/2015/go-gc.pdf&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://dave.cheney.net/tag/godebug&#34;&gt;http://dave.cheney.net/tag/godebug&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/qyuhen/book&#34;&gt;1.5源码分析&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.open-open.com/lib/view/open1435846881544.html&#34;&gt;golang gc 探究&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://wangzhezhe.github.io/blog/2016/04/30/golang-gc/&#34;&gt;golang gc 基本知识&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.oschina.net/translate/debugging-performance-issues-in-go-programs&#34;&gt;go 性能调试问题&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</content>
    <link href="http://www.cwen.pw/2016/go笔记-关于GC.html"></link>
    <author>
      <name>cwen</name>
    </author>
  </entry>
  <entry>
    <title>context 包解读</title>
    <updated>2016-07-31T00:00:00Z</updated>
    <id>tag:www.cwen.pw,2016-07-31:/2016/context 包解读.html</id>
    <content type="html">&lt;p&gt;&lt;code&gt;context&lt;/code&gt; 包困扰我好久，之前在  &lt;code&gt;watch etcd&lt;/code&gt; 的时候首次上手使用这个包，当时并不理解这个包的作用，只知道可以用来关闭 &lt;code&gt;watch&lt;/code&gt; ， 后来被大牛吐槽了，决定深入探究一番。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;简介&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;golang&lt;/code&gt; 中的创建一个新的 &lt;code&gt;goroutine&lt;/code&gt; , 并不会返回像c语言类似的pid，所有我们不能从外部杀死某个goroutine，所有我就得让它自己结束，之前我们用 &lt;code&gt;channel ＋ select&lt;/code&gt; 的方式，来解决这个问题，但是有些场景实现起来比较麻烦，例如由一个请求衍生出的各个 &lt;code&gt;goroutine&lt;/code&gt; 之间需要满足一定的约束关系，以实现一些诸如有效期，中止routine树，传递请求全局变量之类的功能。于是google 就为我们提供一个解决方案，开源了 &lt;code&gt;context&lt;/code&gt; 包。使用 &lt;code&gt;context&lt;/code&gt; 实现上下文功能约定需要在你的方法的传入参数的第一个传入一个 &lt;code&gt;context.Context&lt;/code&gt; 类型的变量。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;源码剖析&lt;/h4&gt;&#xA;&#xA;&lt;h6&gt;context.Context 接口&lt;/h6&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;context&lt;/code&gt; 包的核心&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//  context 包里的方法是线程安全的，可以被多个 goroutine 使用    &#xA;type Context interface {               &#xA;    // 当Context 被 canceled 或是 times out 的时候，Done 返回一个被 closed 的channel      &#xA;    Done() &amp;lt;-chan struct{}        &#xA;    &#xA;    // 在 Done 的 channel被closed 后， Err 代表被关闭的原因   &#xA;    Err() error &#xA;&#xA;    // 如果存在，Deadline 返回Context将要关闭的时间  &#xA;    Deadline() (deadline time.Time, ok bool)&#xA;&#xA;    // 如果存在，Value 返回与 key 相关了的值，不存在返回 nil  &#xA;    Value(key interface{}) interface{}&#xA;}      &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们不需要手动实现这个接口，&lt;code&gt;context&lt;/code&gt; 包已经给我们提供了两个，一个是 &lt;code&gt;Background()&lt;/code&gt;，一个是 &lt;code&gt;TODO()&lt;/code&gt;，这两个函数都会返回一个 &lt;code&gt;Context&lt;/code&gt; 的实例。只是返回的这两个实例都是空 &lt;code&gt;Context&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h6&gt;主要结构&lt;/h6&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;cancelCtx&lt;/code&gt; 结构体继承了 &lt;code&gt;Context&lt;/code&gt; ，实现了 &lt;code&gt;canceler&lt;/code&gt; 方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//*cancelCtx 和 *timerCtx 都实现了canceler接口，实现该接口的类型都可以被直接canceled&#xA;type canceler interface {&#xA;    cancel(removeFromParent bool, err error)&#xA;    Done() &amp;lt;-chan struct{}&#xA;}        &#xA;&#xA;type cancelCtx struct {&#xA;    Context&#xA;    done chan struct{} // closed by the first cancel call.&#xA;    mu       sync.Mutex&#xA;    children map[canceler]bool // set to nil by the first cancel call&#xA;    err      error             // 当其被cancel时将会把err设置为非nil&#xA;}&#xA;&#xA;func (c *cancelCtx) Done() &amp;lt;-chan struct{} {&#xA;    return c.done&#xA;}&#xA;&#xA;func (c *cancelCtx) Err() error {&#xA;    c.mu.Lock()&#xA;    defer c.mu.Unlock()&#xA;    return c.err&#xA;}&#xA;&#xA;func (c *cancelCtx) String() string {&#xA;    return fmt.Sprintf(&amp;quot;%v.WithCancel&amp;quot;, c.Context)&#xA;}&#xA;&#xA;//核心是关闭c.done&#xA;//同时会设置c.err = err, c.children = nil&#xA;//依次遍历c.children，每个child分别cancel&#xA;//如果设置了removeFromParent，则将c从其parent的children中删除&#xA;func (c *cancelCtx) cancel(removeFromParent bool, err error) {&#xA;    if err == nil {&#xA;        panic(&amp;quot;context: internal error: missing cancel error&amp;quot;)&#xA;    }&#xA;    c.mu.Lock()&#xA;    if c.err != nil {&#xA;        c.mu.Unlock()&#xA;        return // already canceled&#xA;    }&#xA;    c.err = err&#xA;    close(c.done)&#xA;    for child := range c.children {&#xA;        // NOTE: acquiring the child&#39;s lock while holding parent&#39;s lock.&#xA;        child.cancel(false, err)&#xA;    }&#xA;    c.children = nil&#xA;    c.mu.Unlock()&#xA;&#xA;    if removeFromParent {&#xA;        removeChild(c.Context, c) // 从此处可以看到 cancelCtx的Context项是一个类似于parent的概念&#xA;    }&#xA;}         &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;timerCtx&lt;/code&gt; 结构继承 &lt;code&gt;cancelCtx&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type timerCtx struct {&#xA;    cancelCtx //此处的封装为了继承来自于cancelCtx的方法，cancelCtx.Context才是父亲节点的指针&#xA;    timer *time.Timer // Under cancelCtx.mu. 是一个计时器&#xA;    deadline time.Time&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;valueCtx&lt;/code&gt; 结构继承 &lt;code&gt;cancelCtx&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type valueCtx struct {&#xA;    Context&#xA;    key, val interface{}&#xA;}        &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h6&gt;主要方法&lt;/h6&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func WithCancel(parent Context) (ctx Context, cancel CancelFunc)&#xA;func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)&#xA;func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)&#xA;func WithValue(parent Context, key interface{}, val interface{}) Context&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;WithCancel&lt;/code&gt; 对应的是 &lt;code&gt;cancelCtx&lt;/code&gt; ,其中，返回一个 &lt;code&gt;cancelCtx&lt;/code&gt; ，同时返回一个 &lt;code&gt;CancelFunc&lt;/code&gt;，&lt;code&gt;CancelFunc&lt;/code&gt; 是 &lt;code&gt;context&lt;/code&gt; 包中定义的一个函数类型：&lt;code&gt;type CancelFunc func()&lt;/code&gt;。调用这个 &lt;code&gt;CancelFunc&lt;/code&gt; 时，关闭对应的c.done，也就是让他的后代&lt;code&gt;goroutine&lt;/code&gt;退出。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;WithDeadline&lt;/code&gt; 和 &lt;code&gt;WithTimeout&lt;/code&gt; 对应的是 &lt;code&gt;timerCtx&lt;/code&gt; ，&lt;code&gt;WithDeadline&lt;/code&gt; 和 &lt;code&gt;WithTimeout&lt;/code&gt; 是相似的，&lt;code&gt;WithDeadline&lt;/code&gt; 是设置具体的 &lt;code&gt;deadline&lt;/code&gt; 时间，到达 &lt;code&gt;deadline&lt;/code&gt; 的时候，后代 &lt;code&gt;goroutine&lt;/code&gt; 退出，而 WithTimeout 简单粗暴，直接 &lt;code&gt;return WithDeadline(parent, time.Now().Add(timeout))&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;WithValue&lt;/code&gt; 对应 &lt;code&gt;valueCtx&lt;/code&gt; ，&lt;code&gt;WithValue&lt;/code&gt; 是在 &lt;code&gt;Context&lt;/code&gt; 中设置一个 map，拿到这个 &lt;code&gt;Context&lt;/code&gt; 以及它的后代的 &lt;code&gt;goroutine&lt;/code&gt; 都可以拿到 map 里的值。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;详细 context 包源码解读: &lt;a href=&#34;http://studygolang.com/articles/5131&#34;&gt;go源码解读&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;使用原则&lt;/h4&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;Context&lt;/code&gt; 的程序包需要遵循如下的原则来满足接口的一致性以及便于静态分析&lt;/li&gt;&#xA;&lt;li&gt;不要把 &lt;code&gt;Context&lt;/code&gt; 存在一个结构体当中，显式地传入函数。&lt;code&gt;Context&lt;/code&gt; 变量需要作为第一个参数使用，一般命名为&lt;code&gt;ctx&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;即使方法允许，也不要传入一个 &lt;code&gt;nil&lt;/code&gt; 的 &lt;code&gt;Context&lt;/code&gt; ，如果你不确定你要用什么 &lt;code&gt;Context&lt;/code&gt; 的时候传一个 &lt;code&gt;context.TODO&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;context&lt;/code&gt; 的 &lt;code&gt;Value&lt;/code&gt; 相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数&lt;/li&gt;&#xA;&lt;li&gt;同样的 &lt;code&gt;Context&lt;/code&gt; 可以用来传递到不同的 &lt;code&gt;goroutine&lt;/code&gt; 中，&lt;code&gt;Context&lt;/code&gt; 在多个&lt;code&gt;goroutine&lt;/code&gt; 中是安全的&lt;br /&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h4&gt;使用示例&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;例子copy自: &lt;a href=&#34;https://github.com/eleme/sre/blob/master/context.md&#34;&gt;关于 Golang 中的 context 包的介绍&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;    &amp;quot;golang.org/x/net/context&amp;quot;&#xA;)&#xA;&#xA;// 模拟一个最小执行时间的阻塞函数&#xA;func inc(a int) int {&#xA;    res := a + 1                // 虽然我只做了一次简单的 +1 的运算,&#xA;    time.Sleep(1 * time.Second) // 但是由于我的机器指令集中没有这条指令,&#xA;    // 所以在我执行了 1000000000 条机器指令, 续了 1s 之后, 我才终于得到结果。B)&#xA;    return res&#xA;}&#xA;&#xA;// 向外部提供的阻塞接口&#xA;// 计算 a + b, 注意 a, b 均不能为负&#xA;// 如果计算被中断, 则返回 -1&#xA;func Add(ctx context.Context, a, b int) int {&#xA;    res := 0&#xA;    for i := 0; i &amp;lt; a; i++ {&#xA;        res = inc(res)&#xA;        select {&#xA;        case &amp;lt;-ctx.Done():&#xA;            return -1&#xA;        default:&#xA;        }&#xA;    }&#xA;    for i := 0; i &amp;lt; b; i++ {&#xA;        res = inc(res)&#xA;        select {&#xA;        case &amp;lt;-ctx.Done():&#xA;            return -1&#xA;        default:&#xA;        }&#xA;    }&#xA;    return res&#xA;}&#xA;&#xA;func main() {&#xA;    {&#xA;        // 使用开放的 API 计算 a+b&#xA;        a := 1&#xA;        b := 2&#xA;        timeout := 2 * time.Second&#xA;        ctx, _ := context.WithTimeout(context.Background(), timeout)&#xA;        res := Add(ctx, 1, 2)&#xA;        fmt.Printf(&amp;quot;Compute: %d+%d, result: %d\n&amp;quot;, a, b, res)&#xA;    }&#xA;    {&#xA;        // 手动取消&#xA;        a := 1&#xA;        b := 2&#xA;        ctx, cancel := context.WithCancel(context.Background())&#xA;        go func() {&#xA;            time.Sleep(2 * time.Second)&#xA;            cancel() // 在调用处主动取消&#xA;        }()&#xA;        res := Add(ctx, 1, 2)&#xA;        fmt.Printf(&amp;quot;Compute: %d+%d, result: %d\n&amp;quot;, a, b, res)&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方完整示例:&lt;br /&gt;&#xA;&lt;a href=&#34;https://blog.golang.org/context/server/server.go&#34;&gt;server&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;https://blog.golang.org/context/userip/userip.go&#34;&gt;userip&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;https://blog.golang.org/context/google/google.go&#34;&gt;google&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;部分参考：&lt;br /&gt;&#xA;&lt;a href=&#34;http://studygolang.com/articles/5131&#34;&gt;go源码解读&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;https://github.com/eleme/sre/blob/master/context.md&#34;&gt;关于 Golang 中的 context 包的介绍&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://blog.golang.org/context&#34;&gt;官方博客&lt;/a&gt;&lt;br /&gt;&#xA;Thanks&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</content>
    <link href="http://www.cwen.pw/2016/context 包解读.html"></link>
    <author>
      <name>cwen</name>
    </author>
  </entry>
  <entry>
    <title>初识 Docker</title>
    <updated>2016-06-23T00:00:00Z</updated>
    <id>tag:www.cwen.pw,2016-06-23:/2016/初识 Docker.html</id>
    <content type="html">&lt;p&gt;Docker 是一个开源的应用容器引擎，使用 golang 开发实现，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;br /&gt;&#xA;Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。&lt;br /&gt;&#xA;在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;Docker 组成&lt;/h4&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Image - 镜像&lt;/li&gt;&#xA;&lt;li&gt;Containter - 容器&lt;/li&gt;&#xA;&lt;li&gt;Docker hub - 仓库&lt;br /&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h4&gt;安装 Docker&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;安装 Docker 要求 linux 内核版本不低于 3.13，Docker 依赖 linux 内核，使用 linux 的 namespae 实现进程的隔离，cgroup 来对资源的控制。(docker 与 linux 内核的关系以后单独研究，其实目前我不是太清楚，不敢瞎说) 如果你的内核版本低于 3.13，请自行 google 升级内核。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;查看自己内核版本信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ uname -a&#xA;Linux Host 3.16.0-43-generic #58~14.04.1-Ubuntu SMP Mon Jun 22 10:21:20 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cat /proc/version&#xA;Linux version 3.16.0-43-generic (buildd@brownie) (gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ) #58~14.04.1-Ubuntu SMP Mon Jun 22 10:21:20 UTC 2015&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;Ubuntu 安装&lt;/h4&gt;&#xA;&#xA;&lt;h6&gt;更新APT镜像源&lt;/h6&gt;&#xA;&#xA;&lt;p&gt;安装 apt-transport-https 包支持 https 协议的源&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; $ sudo apt-get update &#xA; $ sudo apt-get install apt-transport-https ca-certificates&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;添加新的 gpg 密钥&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;添加 Docker 的官方 apt 软件源&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/apt/sources.list.d/docker.list&#xA;deb https://apt.dockerproject.org/repo ubuntu-trusty main&#xA;EOF  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;非 trusty 版本的系统注意修改为自己对应的代号&lt;br /&gt;&#xA;deb &lt;a href=&#34;https://apt.dockerproject.org/repo&#34;&gt;https://apt.dockerproject.org/repo&lt;/a&gt; ubuntu-precise main&lt;br /&gt;&#xA;deb &lt;a href=&#34;https://apt.dockerproject.org/repo&#34;&gt;https://apt.dockerproject.org/repo&lt;/a&gt; ubuntu-trusty main&lt;br /&gt;&#xA;deb &lt;a href=&#34;https://apt.dockerproject.org/repo&#34;&gt;https://apt.dockerproject.org/repo&lt;/a&gt; ubuntu-wily main&lt;br /&gt;&#xA;deb &lt;a href=&#34;https://apt.dockerproject.org/repo&#34;&gt;https://apt.dockerproject.org/repo&lt;/a&gt; ubuntu-xenial main&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;更新 apt 软件包缓存&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get update   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果系统中存在老版本的 Docker，请先删除&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get purge lxc-docker    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;检查 apt 源是否发生改变&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ apt-cache policy docker-engine   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h6&gt;更新系统内核和安装可能需要的软件包&lt;/h6&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get install linux-image-extra-$(uname -r)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;linux-image-extra&lt;/code&gt; 允许你使用 &lt;code&gt;aufs&lt;/code&gt; 文件系统&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h6&gt;安装 Docker&lt;/h6&gt;&#xA;&#xA;&lt;p&gt;更新 apt 源&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get update &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装 Docker&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get install docker-engine     &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;启动 Docker 守护进程&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo service docker start  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;检查 Docker 是否安装成功&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo docker run hello-world  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h6&gt;使用脚本安装 Docker&lt;/h6&gt;&#xA;&#xA;&lt;p&gt;使用官方提供的安装脚本, 使用脚本我们可以直接运行，之前的步骤都可以省略&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo-i&#xA;$ wget -qO- https://get.docker.com/ | sh  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h6&gt;把当前用户加入 Docker 用户组&lt;/h6&gt;&#xA;&#xA;&lt;p&gt;运行 Docker 需 root 权限， 为了我们不必一直使用 root 权限，我们可以把用户加进 Docker 用户组&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo usermod -a -G docker [username]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Ubuntu is all set up!&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</content>
    <link href="http://www.cwen.pw/2016/初识 Docker.html"></link>
    <author>
      <name>cwen</name>
    </author>
  </entry>
  <entry>
    <title>jQuery 中 attr() 和 prop() 方法</title>
    <updated>2016-03-09T00:00:00Z</updated>
    <id>tag:www.cwen.pw,2016-03-09:/2016/jQuery 中 attr() 和 prop() 方法.html</id>
    <content type="html">&lt;p&gt;昨天在使用JQuery实现一个一键全选的功能的时候，在设置 &lt;code&gt;checkbox&lt;/code&gt; 属性后，只是在第一有效，过后的N次一直无法改变。一开始还以为自己代码是不是神马地方的逻辑出了问题，可是在检查的多次之后依然无法找到答案，最后只能求助Google(按常理来说一般先翻文档),先上我之前出问题的代码。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;(function() {&#xA;    var dom = {&#xA;        dbTransferAll : $(&#39;#dbTransferAll&#39;),&#xA;        dbCollections : $(&amp;quot;form div:first input[name=&#39;collection&#39;]&amp;quot;)&#xA;    }&#xA;&#xA;    var dbTransfer = {&#xA;        init : function() {&#xA;            this.eventFn();&#xA;        },&#xA;&#xA;        eventFn : function() {&#xA;            dom.dbTransferAll.bind(&#39;click&#39;,function() {&#xA;                &#xA;                if (this.checked == true) {&#xA;                    dom.dbCollections.attr(&amp;quot;checked&amp;quot;,true);&#xA;                } else {&#xA;                    dom.dbCollections.attr(&amp;quot;checked&amp;quot;, false); &#xA;                }&#xA;                &#xA;            });&#xA;        }&#xA;    }&#xA;    dbTransfer.init();&#xA;})();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后通过诸位大神的博客得知，是使用了 &lt;code&gt;attr()&lt;/code&gt; 方法的问题， 在JQuery在1.6版本之后新增了一个 &lt;code&gt;prop()&lt;/code&gt; 方法(羞愧啊！一直不知道),应该使用 &lt;code&gt;prop()&lt;/code&gt; 方法替换 &lt;code&gt;attr()&lt;/code&gt; 。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;为什么要新加 &lt;code&gt;prop()&lt;/code&gt; 方法&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;jQuery 1.6之前 ，&lt;code&gt;attr()&lt;/code&gt; 方法在取某些 &lt;code&gt;attribute&lt;/code&gt; 的值时，会返回 &lt;code&gt;property&lt;/code&gt; 的值，这就导致了结果的不一致。从 jQuery 1.6 开始， &lt;code&gt;prop()&lt;/code&gt; 方法 方法返回 &lt;code&gt;property&lt;/code&gt; 的值,而 &lt;code&gt;attr()&lt;/code&gt; 方法返回 &lt;code&gt;attributes&lt;/code&gt; 的值。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;attribute和property的区别&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;attribute&lt;/code&gt; 翻译成中文术语为“特性”，&lt;code&gt;property&lt;/code&gt; 翻译成中文术语为“属性”，从中文的字面意思来看，确实是有点区别了，先来说说&lt;code&gt;attribute&lt;/code&gt; 。&lt;br /&gt;&#xA;attribute是一个特性节点，每个DOM元素都有一个对应的 &lt;code&gt;attributes&lt;/code&gt; 属性来存放所有的 &lt;code&gt;attribute&lt;/code&gt; 节点，&lt;code&gt;attributes&lt;/code&gt; 是一个类数组的容器，说得准确点就是 &lt;code&gt;NameNodeMap&lt;/code&gt;，总之就是一个类似数组但又和数组不太一样的容器。&lt;code&gt;attributes&lt;/code&gt; 的每个数字索引以名值对 &lt;code&gt;(name=”value”)&lt;/code&gt; 的形式存放了一个 &lt;code&gt;attribute&lt;/code&gt; 节点。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot; id=&amp;quot;box&amp;quot; gameid=&amp;quot;880&amp;quot;&amp;gt;hello&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面的div元素的HTML代码中有class、id还有自定义的gameid，这些特性都存放在attributes中，类似下面的形式：&#xA;view sourceprint?&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[ class=&amp;quot;box&amp;quot;, id=&amp;quot;box&amp;quot;, gameid=&amp;quot;880&amp;quot; ]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;property&lt;/code&gt; 就是一个属性，如果把DOM元素看成是一个普通的 &lt;code&gt;Object&lt;/code&gt; 对象，那么 &lt;code&gt;property&lt;/code&gt; 就是一个以名值对&lt;code&gt;(name=”value”)&lt;/code&gt; 的形式存放在 &lt;code&gt;Object&lt;/code&gt; 中的属性。要添加和删除 &lt;code&gt;property&lt;/code&gt; 也简单多了，和普通的对象没啥分别。&lt;br /&gt;&#xA;之所以 &lt;code&gt;attribute&lt;/code&gt; 和 &lt;code&gt;property&lt;/code&gt; 容易混倄在一起的原因是，很多 &lt;code&gt;attribute&lt;/code&gt; 节点还有一个相对应的 &lt;code&gt;property&lt;/code&gt; 属性，比如上面的 &lt;code&gt;div&lt;/code&gt; 元素的 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; 既是 &lt;code&gt;attribute&lt;/code&gt; ，也有对应的 &lt;code&gt;property&lt;/code&gt; ，不管使用哪种方法都可以访问和修改。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;DOM元素一些默认常见的 &lt;code&gt;attribute&lt;/code&gt; 节点都有与之对应的 &lt;code&gt;property&lt;/code&gt; 属性，比较特殊的是一些值为 &lt;code&gt;Boolean&lt;/code&gt; 类型的&lt;code&gt;property&lt;/code&gt;(这个地方&lt;code&gt;attr()&lt;/code&gt;与&lt;code&gt;prop()&lt;/code&gt;不同点)，如一些表单元素：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; checked=&amp;quot;checked&amp;quot; id=&amp;quot;raido&amp;quot;&amp;gt;&#xA;var radio = document.getElementById( &#39;radio&#39; );&#xA;console.log( radio.getAttribute(&#39;checked&#39;) ); // checked&#xA;console.log( radio.checked ); // true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对于这些特殊的&lt;code&gt;attribute&lt;/code&gt;节点，只有存在该节点，对应的&lt;code&gt;property&lt;/code&gt; 的值就为true，如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; checked=&amp;quot;anything&amp;quot; id=&amp;quot;raido&amp;quot;&amp;gt;&#xA;var radio = document.getElementById( &#39;radio&#39; );&#xA;console.log( radio.getAttribute(&#39;checked&#39;) ); // anything&#xA;console.log( radio.checked ); // true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后为了更好的区分&lt;code&gt;attribute&lt;/code&gt;和&lt;code&gt;property&lt;/code&gt;，基本可以总结为&lt;code&gt;attribute&lt;/code&gt;节点都是在HTML代码中可见的，而&lt;code&gt;property&lt;/code&gt;只是一个普通的名值对属性。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// gameid和id都是attribute节点&#xA;// id同时又可以通过property来访问和修改&#xA;&amp;lt;div gameid=&amp;quot;880&amp;quot; id=&amp;quot;box&amp;quot;&amp;gt;hello&amp;lt;/div&amp;gt;&#xA;// areaid仅仅是property&#xA;elem.areaid = 900;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;神马时候使用 &lt;code&gt;attr()&lt;/code&gt; ? 神马时候使用 &lt;code&gt;prop()&lt;/code&gt; ?&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;根据官方的建议：具有 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 两个属性的属性，如 &lt;code&gt;checked&lt;/code&gt;, &lt;code&gt;selected&lt;/code&gt; 或者 &lt;code&gt;disabled&lt;/code&gt; 使用&lt;code&gt;prop()&lt;/code&gt;，其他的使用 &lt;code&gt;attr()&lt;/code&gt; 。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;文章部分参考 &lt;a href=&#34;http://stylechen.com/attribute-property.html&#34;&gt;attribute和property的区别&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</content>
    <link href="http://www.cwen.pw/2016/jQuery 中 attr() 和 prop() 方法.html"></link>
    <author>
      <name>cwen</name>
    </author>
  </entry>
  <entry>
    <title>golang 编程基础 - Hello,Word</title>
    <updated>2015-12-02T00:00:00Z</updated>
    <id>tag:www.cwen.pw,2015-12-02:/2015/golang 编程基础 - Hello,Word.html</id>
    <content type="html">&lt;p&gt;最近越发觉得自己的golang基础还是不够扎实,所有决定再从头捋一遍golang的基础知识&#xA;同时也为golang的爱好者们提供点入门材料.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们就从这个经典的 &lt;code&gt;Hello Word&lt;/code&gt; 案例开始吧!(先上代码)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//HelloWord.go&#xA;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;func main() {&#xA;    fmt.Println(&amp;quot;Hello, Word&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接着我们打开终端&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cd $GOPATH/src/***    //进入你的文件目录 &#xA;$ go run helloWord.go  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;毫不意外,命令会输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Hello,Word&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;同时我们还可以这样来干&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ go build helloWord.go  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样你会在当前目录下找到一个可执行的二进制文件,不需要任何其他处理下,你就可以在任何时间来运行这个二进制文件了(注：因为是静态编译，所以也不用担心在系统库更新的时候冲突，幸福感满满)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ ./helloWord&#xA;Helllo,Word&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;代码详解&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;看到代码的第一行,熟悉 Java,Python 的同学会觉得很熟悉,没错golang也是使用 &lt;code&gt;package&lt;/code&gt; 的来组织代码的, 一个 &lt;code&gt;package&lt;/code&gt; 会包含一个或多个&lt;code&gt;.go&lt;/code&gt;结束的源代码文件。每一个源文件都是以一个 &lt;code&gt;package xxx&lt;/code&gt;的声明开头的，比如我们的例子里就是 &lt;code&gt;package main&lt;/code&gt; 。这行声明表示该文件是属于哪一个 &lt;code&gt;package&lt;/code&gt;，紧跟着是一系列 &lt;code&gt;import&lt;/code&gt; 的 &lt;code&gt;package&lt;/code&gt; 名，表示这个文件中引入的 &lt;code&gt;package&lt;/code&gt; 。再之后是本文件本身的代码&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;main.main 为函数的入口(main包 main函数)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;代码的第二句相信大家也都猜到了,导入 &lt;code&gt;fmt&lt;/code&gt; 包,&lt;br /&gt;&#xA;&lt;code&gt;fmt&lt;/code&gt; 包是干什么的呢?&lt;br /&gt;&#xA;&lt;code&gt;fmt&lt;/code&gt; 包实现了类似 &lt;code&gt;C&lt;/code&gt; 语言 &lt;code&gt;printf&lt;/code&gt; 和 &lt;code&gt;scanf&lt;/code&gt; 的格式化 &lt;code&gt;I/O&lt;/code&gt; 。格式化动作（&amp;rsquo;verb&amp;rsquo;）源自C语言但更简单。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下让我们来看 &lt;code&gt;main&lt;/code&gt; 函数, &lt;code&gt;main&lt;/code&gt; 必须存在与 &lt;code&gt;main&lt;/code&gt; 包内, 这是我们整个程序的入口(注：其实c系语言差不多都是这样)。main函数所做的事情就是我们程序做的事情。当然了，&lt;code&gt;main&lt;/code&gt; 函数一般完成的工作是调用其它 &lt;code&gt;packge&lt;/code&gt; 里的函数来完成自己的工作，比如 &lt;code&gt;fmt.Println&lt;/code&gt; 。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 函数内我们调用了 &lt;code&gt;fmt&lt;/code&gt; 包里面定义的函数 &lt;code&gt;Println&lt;/code&gt;。大家可以看到，这个函数是通过&lt;code&gt;&amp;lt;pkgName&amp;gt;.&amp;lt;funcName&amp;gt;&lt;/code&gt;的方式调用的.&lt;br /&gt;&#xA;&lt;code&gt;Println&lt;/code&gt; 函数类似与 c 语言的 &lt;code&gt;printf&lt;/code&gt; ,只是在 &lt;code&gt;printf&lt;/code&gt; 函数的基础上在输出最后加上一个格式化换行符.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;到此我们的 &lt;code&gt;helloWord.go&lt;/code&gt; 代码分析结束&lt;br /&gt;&#xA;下一篇博文让我真正的走进golang &lt;code&gt;&amp;lt;&amp;lt;goalng编程基础-基本语法&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</content>
    <link href="http://www.cwen.pw/2015/golang 编程基础 - Hello,Word.html"></link>
    <author>
      <name>cwen</name>
    </author>
  </entry>
  <entry>
    <title>Markdown写作规范参考</title>
    <updated>2015-11-27T00:00:00Z</updated>
    <id>tag:www.cwen.pw,2015-11-27:/2015/Markdown写作规范参考.html</id>
    <content type="html">&lt;p&gt;之前转发了GC的一篇介绍markdown的写作语法以及如何在页面里引用markdown的文章,写的已经很全面了,我在此就不做多余的介绍了,有兴趣可以自行查阅&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.igouc.com/jsp/Journal/journal_each.jsp?id=12&#34;&gt;Markdown-入门指南及网站整合&lt;/a&gt; .其实每个人都有自己的写作规范,在此我只是简单的说说我的markdown写作规范,以供大家参考.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;1. 如何使用加粗&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;markdown提供两种方法&#xA;&lt;code&gt;**加粗**&lt;/code&gt; 或是 &lt;code&gt;__加粗__&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是我个人推荐使用 &lt;code&gt;**加粗**&lt;/code&gt;&#xA;&lt;a name=&#34;reason&#34;&gt;推荐理由&lt;/a&gt;:喜欢就好（但是要统一用法，最好别再一篇文章里混用，这样文章会显得很乱，不易于以后修改)&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;2. 如何使用斜体　　&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;markdown提供两种方法&#xA;&lt;code&gt;*加斜*&lt;/code&gt; 或是 &lt;code&gt;_加斜_&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是我个人推荐使用 &lt;code&gt;*加斜*&lt;/code&gt;&#xA;推荐理由:&lt;a href=&#34;#reason&#34;&gt;同上&lt;/a&gt;！&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;3. 如何使用加粗并斜体&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;加粗和斜体的组合应该又四种&#xA;&lt;code&gt;***加粗并斜体***&lt;/code&gt;、&lt;code&gt;**_加粗并斜体_**&lt;/code&gt;、&lt;code&gt;__*加粗并斜体*__&lt;/code&gt;、&lt;code&gt;___加粗并斜体___&lt;/code&gt;&#xA;如果我们在一篇文章里混用这四种,那我们在修改的时候可想而知,呵呵&amp;hellip;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;个人推荐:&lt;code&gt;***加粗并斜体***&lt;/code&gt;&#xA;推荐理由:既然我们已经选择的单加粗以及单斜体的用法,那我们就继续任性到底呗&amp;hellip;.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;4. 如何使用标题&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;h1 两种方式&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# 这是文章h1标题&#xA;这也是文章h1标题&#xA;=========&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;h2两种方式&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;## 这是文章h2标题&#xA;这是文章h2标题&#xA;-------&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;h3&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;### h3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;h4, h5, h6  &amp;hellip;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;个人推荐: 全部都用 &lt;code&gt;#&lt;/code&gt; 这个系列&#xA;推荐理由: 喜欢就好（但是要统一用法，最好别再一篇文章里混用，这样文章会显得很乱，不易于以后修改)&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;5. 如何使用连接&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;markdown 提供两种连接方法&#xA;    1. 普通连接: &lt;code&gt;[显示文本](连接地址)&lt;/code&gt;     图像连接: &lt;code&gt;![](图像连接地址)&lt;/code&gt;&#xA;    2. 普通连接: &lt;code&gt;[显示文本][连接标签]&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;个人推荐: 段落内使用 &lt;code&gt;[显示文本][连接标签]&lt;/code&gt; ,左右各留一空格,&#xA;不推荐使用 &lt;code&gt;[显示文本](连接地址)&lt;/code&gt;&#xA;推荐理由: &lt;code&gt;[显示文本](连接地址)&lt;/code&gt; 容易使段落看起来臃肿 ,除非一些特殊情况,具体分析.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;6. 连接的URL放在哪?&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;比如你有这样一个段落：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;这是一个带有[超链接][link-to]的段落。&lt;/code&gt;&#xA;你的 [link-to]: url 放在哪？紧跟段落后面，还是一大章节后面，还是全文最后？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;个人推荐: 放在章节后面,比如放在下一个四级标题前&#xA;推荐理由: 个人绝的好像看起来更爽一点,文本更整洁一点.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;7. 如何使用空格、空行、分隔符&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;空格: 推荐在各级标题 &lt;code&gt;###&lt;/code&gt; 以及列表 &lt;code&gt;*&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;、 &lt;code&gt;-&lt;/code&gt;、 &lt;code&gt;1.&lt;/code&gt; 的后边跟一空格 ,中英文之间加空格,正文与专有名词之间留空格&#xA;空行: 推荐在各级标题 &lt;code&gt;###&lt;/code&gt; 前多留几个空行,&lt;code&gt;###&lt;/code&gt; 后留一空行&#xA;分隔符: 在应该分割的地方，Markdown 支持用一个空行加 &amp;mdash;（可以更多个-） 形成一个&lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt;（分割符）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;推荐理由: 个人感觉更整洁&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;8. 最后总结&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;形成自己的Markdown写作规范, 主要保持、规范、统一、整洁, 便于以后修改.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这篇文章仅代表作者个人观点,仅提供参考&#xA;其实我的写作规范受这篇文章的影响 &lt;a href=&#34;http://www.jianshu.com/p/3bd994e702a7&#34;&gt;Markdown 写作规范参考&lt;/a&gt; 参考了其部分内容 (不是有意参考实在是这已变成了我自己的写作规范)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</content>
    <link href="http://www.cwen.pw/2015/Markdown写作规范参考.html"></link>
    <author>
      <name>cwen</name>
    </author>
  </entry>
  <entry>
    <title>golang自建HTTP服务器</title>
    <updated>2015-11-20T00:00:00Z</updated>
    <id>tag:www.cwen.pw,2015-11-20:/2015/golang自建HTTP服务器.html</id>
    <content type="html">&lt;p&gt;golang作为二十一世纪的编程语言，让我们一起看看golang是如何实现自己的http服务器&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;go封装http服务器简单实例&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;让我们直接来看代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;)&#xA;// hello world, the web server&#xA;func HelloServer(w http.ResponseWriter, req *http.Request) {&#xA;    io.WriteString(w, &amp;quot;hello, world!\n&amp;quot;)&#xA;}&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/hello&amp;quot;, HelloServer)&#xA;    err := http.ListenAndServe(&amp;quot;:12345&amp;quot;, nil)&#xA;    if err != nil {&#xA;        log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;没错就是这么简单运,一个http服务器就搭建成功，只要调用http包的两个函数就可以了。&#xA;这里首先调用的是&lt;code&gt;http.HandleFunc&lt;/code&gt;函数，函数签名如下&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//HandleFunc注册一个处理器函数handler和对应的模式pattern（注册到DefaultServeMux）。&#xA;//ServeMux的文档解释了模式的匹配机制。&#xA;func HandleFunc(pattern string, handler func(ResponseWriter, *Request))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接着就是设置监听端口，使用的是&lt;code&gt;http.ListenAndServer&lt;/code&gt;。函数签名如下&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//ListenAndServe监听TCP地址addr，并且会使用handler参数调用Serve函数处理接收到的连接。&#xA;//handler参数一般会设为nil，此时会使用DefaultServeMux。&#xA;func ListenAndServe(addr string, handler Handler) error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;看到这里我相信大家脑子里会有很多疑惑&amp;hellip;那么我们就接着往下探讨&#xA;我们先从&lt;code&gt;ListenAndServe&lt;/code&gt;这个函数看起，看看它到底为我们做了什么&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;ListenAndServer深入探究&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;我们先从源码看起&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ListenAndServe(addr string, handler Handler) error {&#xA;     server := &amp;amp;Server{Addr: addr, Handler: handler}&#xA;     return server.ListenAndServe()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从函数的参数来看，这个函数传入俩个参数，&lt;code&gt;addr&lt;/code&gt;和&lt;code&gt;handler&lt;/code&gt;，很明显&lt;code&gt;addr&lt;/code&gt;是我们想要监听的端口地址,第二的参数是一个&lt;a href=&#34;https://godoc.org/net/http#Handler&#34; title=&#34;Handler&#34;&gt;Handler&lt;/a&gt;,通过查看文档得知，它是一个只包含了&lt;code&gt;ServeHTTP(ResponseWriter, *Request)&lt;/code&gt;的接口，也就说只要某个&lt;code&gt;struct&lt;/code&gt;有`&lt;code&gt;ServeHTTP(ResponseWriter, *Request)&lt;/code&gt;这个方法，那这个&lt;code&gt;struct&lt;/code&gt;就自动实现了&lt;code&gt;Handler&lt;/code&gt;接口。&#xA;显示什么网页取决于第二个参数&lt;code&gt;Hander&lt;/code&gt;，&lt;code&gt;Hander&lt;/code&gt;又只有1个&lt;code&gt;ServeHTTP&lt;/code&gt;&#xA;所以可以证明，显示什么网页取决于ServeHTTP&#xA;那就&lt;code&gt;ServeHTTP&lt;/code&gt;方法，他需要2个参数，一个是&lt;code&gt;http.ResponseWriter&lt;/code&gt;，另一个是&lt;code&gt;http.Request&lt;/code&gt;&#xA;往&lt;code&gt;http.ResponseWriter&lt;/code&gt;写入什么内容，浏览器的网页源码就是什么内容&#xA;http.Request里面是封装了，浏览器发过来的请求（包含路径、浏览器类型等等）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下来让我来实现一个自己&lt;code&gt;Handler&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;)&#xA;&#xA;type myHandler struct{}&#xA;&#xA;func (*myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {&#xA;    io.WriteString(w, &amp;quot;myHandler Hello Word&amp;quot;)&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    err := http.ListenAndServe(&amp;quot;:12345&amp;quot;, &amp;amp;myHandler{})&#xA;    if err != nil {&#xA;        log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当&lt;code&gt;http.ListenAndServe(&amp;quot;:12345&amp;quot;, &amp;amp;myHandler{})&lt;/code&gt;后，开始等待有访问请求&#xA;一旦有访问请求过来，http包帮我们处理了一系列动作后，最后他会去调用&lt;code&gt;myHandler&lt;/code&gt;的&lt;code&gt;ServeHTTP&lt;/code&gt;这个方法，并把自己已经处理好的&lt;code&gt;http.ResponseWriter&lt;/code&gt;, &lt;code&gt;*http.Request&lt;/code&gt;传进去&#xA;而&lt;code&gt;myHandler&lt;/code&gt;的&lt;code&gt;ServeHTTP&lt;/code&gt;这个方法，拿到&lt;code&gt;*http.ResponseWriter&lt;/code&gt;后，并往里面写东西，客户端的网页就显示出来了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我接着还是回到&lt;code&gt;ListenAndServe&lt;/code&gt;这个函数上，看看这个函数到底为我们干了些什么呢？&#xA;这个底层其实这样处理的：初始化一个&lt;code&gt;server&lt;/code&gt;对象，然后调用了&lt;code&gt;server.ListenAndServe()&lt;/code&gt;&#xA;我们跳到&lt;code&gt;server.ListenAndServe()&lt;/code&gt; 处&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ListenAndServe listens on the TCP network address srv.Addr and then&#xA;// calls Serve to handle requests on incoming connections.  If&#xA;// srv.Addr is blank, &amp;quot;:http&amp;quot; is used.&#xA; func (srv *Server) ListenAndServe() error {&#xA;    addr := srv.Addr&#xA;    if addr == &amp;quot;&amp;quot; {&#xA;        addr = &amp;quot;:http&amp;quot;&#xA;    }&#xA;    ln, err := net.Listen(&amp;quot;tcp&amp;quot;, addr)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以看到其实&lt;code&gt;server.ListenAndServe()&lt;/code&gt;只是调用了&lt;code&gt;net.Listen(&amp;quot;tcp&amp;quot;, addr)&lt;/code&gt;，也就是底层用TCP协议搭建了一个服务，然后监控我们设置的端口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们在看看&lt;code&gt;Serve&lt;/code&gt;函数，&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Serve accepts incoming connections on the Listener l, creating a&#xA;// new service goroutine for each.  The service goroutines read requests and&#xA;// then call srv.Handler to reply to them.&#xA;func (srv *Server) Serve(l net.Listener) error {&#xA;    defer l.Close()&#xA;    var tempDelay time.Duration // how long to sleep on accept failure&#xA;    for {&#xA;        rw, e := l.Accept()&#xA;        if e != nil {&#xA;            if ne, ok := e.(net.Error); ok &amp;amp;&amp;amp; ne.Temporary() {&#xA;                if tempDelay == 0 {&#xA;                    tempDelay = 5 * time.Millisecond&#xA;                } else {&#xA;                    tempDelay *= 2&#xA;                }&#xA;                if max := 1 * time.Second; tempDelay &amp;gt; max {&#xA;                    tempDelay = max&#xA;                }&#xA;                srv.logf(&amp;quot;http: Accept error: %v; retrying in %v&amp;quot;, e, tempDelay)&#xA;                time.Sleep(tempDelay)&#xA;                continue&#xA;            }&#xA;            return e&#xA;        }&#xA;        tempDelay = 0&#xA;        c, err := srv.newConn(rw)&#xA;        if err != nil {&#xA;            continue&#xA;        }&#xA;        c.setState(c.rwc, StateNew) // before Serve can return&#xA;        go c.serve()&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;监控之后如何接收客户端的请求呢？上面代码执行监控端口之后，调用了&lt;code&gt;srv.Serve(net.Listener)&lt;/code&gt;函数，这个函数就是处理接收客户端的请求信息。这个函数里面起了一个&lt;code&gt;for{}&lt;/code&gt;，首先通过&lt;code&gt;Listener&lt;/code&gt;接收请求，其次创建一个&lt;code&gt;Conn&lt;/code&gt;，最后单独开了一个&lt;code&gt;goroutine&lt;/code&gt;，把这个请求的数据当做参数扔给这个&lt;code&gt;conn&lt;/code&gt;去服务：&lt;code&gt;go c.serve()&lt;/code&gt;。这个就是高并发体现了，用户的每一次请求都是在一个新的&lt;code&gt;goroutine&lt;/code&gt;去服务，相互不影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么如何具体分配到相应的函数来处理请求呢？&lt;code&gt;conn&lt;/code&gt;首先会解析&lt;code&gt;request:c.readRequest()&lt;/code&gt;,然后获取相应的&lt;code&gt;handler:handler := c.server.Handler&lt;/code&gt;，也就是我们刚才在调用函数&lt;code&gt;ListenAndServe&lt;/code&gt;时候的第二个参数，我们前面例子传递的是&lt;code&gt;nil&lt;/code&gt;，也就是为空，那么默认获取&lt;code&gt;handler = DefaultServeMux&lt;/code&gt;,那么这个变量用来做什么的呢？对，这个变量就是一个路由器，它用来匹配url跳转到其相应的&lt;code&gt;handle&lt;/code&gt;函数，那么这个我们有设置过吗?有，我们调用的代码里面第一句不是调用了&lt;code&gt;http.HandleFunc(&amp;quot;/&amp;quot;, HelloServer)&lt;/code&gt;嘛。这个作用就是注册了请求/的路由规则，当请求&lt;code&gt;uri&lt;/code&gt;为&lt;code&gt;&amp;quot;/&amp;quot;&lt;/code&gt;，路由就会转到函数&lt;code&gt;HelloServer&lt;/code&gt;，&lt;code&gt;DefaultServeMux&lt;/code&gt;会调用&lt;code&gt;ServeHTTP&lt;/code&gt;方法，这个方法内部其实就是调用&lt;code&gt;HelloServer&lt;/code&gt;本身，最后通过写入&lt;code&gt;response&lt;/code&gt;的信息反馈到客户端。&#xA;&lt;img src=&#34;http://7xnp02.com1.z0.glb.clouddn.com/3.3.illustrator.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;strong&gt;http连接处理流程(图片摘自&lt;a href=&#34;https://github.com/astaxie/build-web-application-with-golang&#34;&gt;go web编程&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;路由处理&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;实际上我们在前边也多多少少谈到了路由，前面有说到实现&lt;code&gt;Handler&lt;/code&gt;接口的&lt;code&gt;struct&lt;/code&gt;,没错我们可以在这个&lt;code&gt;struct&lt;/code&gt;的&lt;code&gt;ServeHTTP&lt;/code&gt;函数中进行路由判断&#xA;来看下面这个例子&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;)&#xA;&#xA;type myHandler struct{}&#xA;&#xA;func (*myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {&#xA;    path := r.URL.String()&#xA;    switch path {&#xA;    case &amp;quot;/&amp;quot;:&#xA;        io.WriteString(w, &amp;quot;&amp;lt;h1&amp;gt;root&amp;lt;/h1&amp;gt;&amp;lt;a href=\&amp;quot;abc\&amp;quot;&amp;gt;abc&amp;lt;/a&amp;gt;&amp;quot;)&#xA;    case &amp;quot;/abc&amp;quot;:&#xA;        io.WriteString(w, &amp;quot;&amp;lt;h1&amp;gt;abc&amp;lt;/h1&amp;gt;&amp;lt;a href=\&amp;quot;/\&amp;quot;&amp;gt;root&amp;lt;/a&amp;gt;&amp;quot;)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    err := http.ListenAndServe(&amp;quot;:12345&amp;quot;, &amp;amp;myHandler{})&#xA;    if err != nil {&#xA;        log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;没错每一个&lt;code&gt;case&lt;/code&gt;就是一个页面，那么问题来了如果一个网站有上百个页面，肿么办？上百个&lt;code&gt;case&lt;/code&gt;？答案是否定的(其实上百个&lt;code&gt;case&lt;/code&gt;是可以实现)。那我们该肿么做呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那接下来看看&lt;code&gt;ServeMux&lt;/code&gt;吧&amp;hellip;.&#xA;其实&lt;code&gt;ServeMax&lt;/code&gt;存在一张&lt;code&gt;map&lt;/code&gt;表，&lt;code&gt;map&lt;/code&gt;里的&lt;code&gt;key&lt;/code&gt;记录的是&lt;code&gt;r.URL.String()&lt;/code&gt;，而&lt;code&gt;value&lt;/code&gt;记录的是一个方法，这个方法和&lt;code&gt;ServeHTTP&lt;/code&gt;是一样的，这个方法有一个别名，叫&lt;code&gt;HandlerFunc&lt;/code&gt;&#xA;&lt;code&gt;ServeMux&lt;/code&gt;还有一个方法名字是&lt;code&gt;Handle&lt;/code&gt;，他是用来注册&lt;code&gt;HandlerFunc&lt;/code&gt; 的&#xA;&lt;code&gt;ServeMux&lt;/code&gt;还有另一个方法名字是&lt;code&gt;ServeHTTP&lt;/code&gt;，这样&lt;code&gt;ServeMux&lt;/code&gt;是实现&lt;code&gt;Handler&lt;/code&gt;接口的，否者无法当&lt;code&gt;http.ListenAndServe&lt;/code&gt;的第二个参数传输&#xA;我们直接上源码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ServeMux struct {&#xA;    mu sync.RWMutex   //锁，由于请求涉及到并发处理，因此这里需要一个锁机制&#xA;    m  map[string]muxEntry  //路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式&#xA;    hosts bool // 是否在任意的规则中带有host信息&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;再看 &lt;code&gt;muxEntry&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type muxEntry struct {&#xA;    explicit bool   // 是否精确匹配&#xA;    h        Handler // 这个路由表达式对应哪个handler&#xA;    pattern  string  //匹配字符串&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;你是不是有一个疑问？那就是我们什么时候用ServeMax？接下来我就为你解答这和问题&#xA;其实当我们在调用&lt;code&gt;http.ListenAndServe(&amp;quot;:12345&amp;quot;, nil)&lt;/code&gt;的时候，第2个参数是nil时&#xA;&lt;code&gt;http&lt;/code&gt;内部会自己建立一个叫&lt;code&gt;DefaultServeMux&lt;/code&gt;的&lt;code&gt;ServeMux&lt;/code&gt;，因为这个&lt;code&gt;ServeMux&lt;/code&gt;是&lt;code&gt;http&lt;/code&gt;自己维护的，如果要向这个&lt;code&gt;ServeMux&lt;/code&gt;注册的话，就要用http.HandleFunc这个方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在我们在看最一开始的&lt;code&gt;http.HandleFunc(&amp;quot;/hello&amp;quot;, HelloServer)&lt;/code&gt; 就会问&lt;code&gt;HelloServer&lt;/code&gt; 不是没有实现&lt;code&gt;Handler&lt;/code&gt;接口吗？(其实这个地方我也纠结了好久，后来找了源码以及看了好几篇大牛的博客才明白过来)&#xA;其实在http中存在这样一个类型&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type HandlerFunc func(ResponseWriter, *Request)&#xA;&#xA;// ServeHTTP calls f(w, r).&#xA;func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {&#xA;    f(w, r)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;没错它经过一次类型转换，即我们调用了&lt;code&gt;HandlerFunc(f)&lt;/code&gt;,强制类型转换f成为&lt;code&gt;HandlerFunc&lt;/code&gt;类型，这样f就拥有了&lt;code&gt;ServeHTTP&lt;/code&gt;方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们现在不使用&lt;code&gt;DefaultServeMux&lt;/code&gt;，来自己实现一个&lt;code&gt;ServeMax&lt;/code&gt;，直接上代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;)&#xA;&#xA;type myHandler struct{}&#xA;&#xA;func (*myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {&#xA;    io.WriteString(w, &amp;quot;My server: &amp;quot;+r.URL.String())&#xA;}&#xA;&#xA;func sayBye(w http.ResponseWriter, r *http.Request) {&#xA;    io.WriteString(w, &amp;quot;Bye bye, this is version 2.&amp;quot;)&#xA;}&#xA;&#xA;func main() {&#xA;    mux := http.NewServeMux()&#xA;&#xA;    mux.Handle(&amp;quot;/&amp;quot;, &amp;amp;myHandler{})&#xA;&#xA;    // 使用函数作为 handler&#xA;    mux.HandleFunc(&amp;quot;/bye&amp;quot;, sayBye)&#xA;&#xA;    err = http.ListenAndServe(&amp;quot;:12345&amp;quot;, mux)&#xA;    if err != nil {&#xA;         log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;到这里我们的golang版的http服务器就探究结束了，如果读者有兴趣还可以更深入的探究，尝试实现自己的&lt;code&gt;Server&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;博文参考了 asta谢的&lt;a href=&#34;https://github.com/astaxie/build-web-application-with-golang&#34;&gt;《go web编程》&lt;/a&gt;  以及 waynehu 的 &lt;a href=&#34;http://my.oschina.net/u/943306/blog/151293&#34;&gt;go语言的http包&lt;/a&gt; 的这篇博客，在此感谢这两位作者&#xA;如有发现什不正确或是有疑问的地方，欢迎留言或是发邮件联系博主&#xA;如有转载请注明出处&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</content>
    <link href="http://www.cwen.pw/2015/golang自建HTTP服务器.html"></link>
    <author>
      <name>cwen</name>
    </author>
  </entry>
</feed>